---
title: 1~n整数中1出现的次数
author: 熊滔
category: 剑指offer
---

> 题目：输入一个整数 $n$，求 $1 - n$ 这 $n$ 个整数的十进制表示中 $1$ 出现的次数。例如输入 $12$，$1 - 12$ 这些整数中包含 $1$ 的数字有 $1、 10、 11、 12$，$1$ 一共出现了 $5$ 次。

如果我们不考虑时间效率的话，我们可以从 $1$ 开始遍历到输入的整数，在遍历的过程中统计数字中 $1$ 出现的个数，如下：

```java
public static int numberOfOneToN(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        count += numberOfOne(i);
    }
    return count;
}
private static int numberOfOne(int n) {
    int count = 0;
    while (n != 0) {
        if (n % 10 == 1) {
            count++;
        }
        n /= 10;
    }
    return count;
}
```

上面每次都要对数字求余计算 $1$ 出现的次数，时间复杂度为 $O(n \lg n)$，我们找找是否有数字的规律，我们以数字 $54321$ 为例。我们将数字分为两部分 $1-4321$ 以及 $4322 - 54321$。

那我们首先统计 $4322-54321$ 这 $50000$ 个数字中 $1$ 出现的个数，首先我们统计首位 $1$ 出现的个数，首位为 $1$ 的情况有 $10000 - 19999$ 共 $10^4$ 种情况，如果我们输入的数字最高位是 $1$，比如 $12345$，那么首位为 $1$ 出现的次数为 $10000-12345$ 共$2346$ 种情况。接下来统计后面四位出现 $1$ 的情况，我们随便固定一位为 $1$，另外 $3$ 位可以任意的从 $0-9$ 取值，且首位可以从 $1$ 取到 $5$，共有 $5 * 10^3$ 种情况，总共有四位，所以后面四位为 $1$ 的情况有 $5 * 4 * 10^3$ 种情况。

现在处理 $1-4321$ 的部分，这个部分不就相当于输入数字 $4321$ 求 $1$ 出现的个数嘛！我们可以再次将 $4321$ 也分为两部分，$1- 321$ 以及 $322-4321$，不难看出，这个可以使用递归解决。

```java
public  int numberOf1Between1AndN(int number) {
    char[] str = Integer.toString(number).toCharArray();
    return numberOfOne(str, 0);
}

private static int numberOfOne(char[] str, int start) {
    if (start == str.length) {
        return 0;
    }
    // 最高位
    int first = str[start] - '0';
    int restLength = str.length - start;
    if (restLength == 1 && first == 0) {
        return 0;
    }
    if (restLength == 1 && first > 0) {
        return 1;
    }
    int numFirstDigit = 0;
    if (first > 1) {
        // 如果首位大于 1，那么出现 1 的次数为 10^(n-1)
        // 例如例子中的 10^4
        numFirstDigit = (int)Math.pow(10, restLength - 1);
    } else if (first == 1) {
        // 如果首位是 1，如12345，那么首位出现 1 的次数为 2346
        String s = new String(str);
        s = s.substring(start + 1) ;
        numFirstDigit = Integer.parseInt(s) + 1;
    }
    // 非首位出现的次数为 first(首位数字) * (n - 1) * 10^(n-2)
    // 例如例子中的 5 * 4 * 10^3
    int numOtherDigit = (int)(first * (restLength - 1) * Math.pow(10, restLength - 2));
    // 递归求解另一部分 1 出现的数字
    int numRecursive = numberOfOne(str, start + 1);
    return numFirstDigit + numOtherDigit + numRecursive;
}
```

<Disqus />