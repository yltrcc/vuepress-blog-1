---
title: 多表查询
time: 2019-10-20
category: MySQL
author: 熊滔
commentid: mysql:shiwu
---

所谓事务是指一系列的操作，这些操作
要么同时成功，要么同时失败。比如转账，不能我这里转账成功，你那么收不到钱，那么钱就这么消失了? 如果事务执行成功了，那么就提交，如果有一条失败了，那么就需要进行回滚(即回到之前的状态)。与事务有关的三条语句为

- `start transaction`
  - 开启事务
- `commit`
  - 提交事务
  - 可手动提交，也可设置为自动提交
- `roll back`
  - 回滚事务
  - 当事务执行失败时自动自动，也可手动执行

假设有这么一张表，里面存储的是用户名和余额信息

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql45.png" />

现在张三要向李四转账 500 块，如下

```sql
-- 张三账号-500 
update account set balance = balance - 500 where name='张三'; 
-- 李四账号+500 
update account set balance = balance + 500 where name='李四'; 
```

如果我们不开启事务的话，那么当张三转了 500 块时，这时服务器崩溃了，李四没有收到钱，但是钱还是少了，这种情况是不能发生的，我们应当开启一个事务，这两个操作要么同时成功，要么同时失败。

```sql
START TRANSACTION; -- 开启一个事务

-- 张三账号-500
update account set balance = balance - 500 where name='张三';
-- 李四账号+500
update account set balance = balance + 500 where name='李四';

COMMIT; -- 提交事务
```

开启事务后，所有的操作都在临时日志文件中，`commit` 操作是将临时日志中的内容写到数据库的存储引擎中，所以在提交事务之前，是不会对数据库中的内容进行修改的。而 `rollback` 则是清空临时日志文件，之前没有进行提交的内容全部清除。

事务的步骤可以简述为下面几步

- 客户端连接数据库服务器，创建连接时创建此用户临时日志文件 
- 开启事务以后，所有的操作都会先写入到临时日志文件中 
- 所有的查询操作从表中查询，但会经过日志文件加工后才返回 
- 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件

事务的提交分为自动提交和手动提交，在 `MySQL` 命令行的默认设置下，事务都是自动提交的，即执行 `SQL` 语句后就会马上执行 `COMMIT` 操作。因此要显式地开启一个事务务须使用命令 `BEGIN` 或 `START TRANSACTION`，或者执行命令 `SET AUTOCOMMIT=0`，用来禁止使用当前会话的自动提交。

- **SET AUTOCOMMIT=0** 
  - 禁止自动提交
- **SET AUTOCOMMIT=1** 
  - 开启自动提交

### 事务的特性

事务的四大特性 ACID

- 原子性(Atomicity)
  - 每个事务都是一个整体，不可再拆分，事务中所有的 `SQL` 语句要么都执行成功， 要么都失败。
- 一致性(Consistency)
  - 事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前 2 个人的 总金额是 2000，转账后 2 个人总金额也是 2000 
- 隔离性(Isolation)
  - 事务与事务之间不应该相互影响，执行时保持隔离的状态。 
- 持久性(Durability)
  - 一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 

这篇文章[MySQL事务：ACID特性的实现原理总结分析](https://zhuanlan.zhihu.com/p/60723043)详细讲解了 MySQL 的事务，所以在这里我不多做介绍，因为讲的没人家好。

### 事务的隔离级别

事务在操作时的理想状态是所有的事务之间保持隔离，互不影响。但是因为并发操作，多个用户同时访问同一个数据时，可能引发并发访问的问题，如

- 脏读 
  - 一个事务读取到了另一个事务中尚未提交的数据
  - 比如李四向张三转了 500 块，但是没有提交，这时张三读取数据，发现已经到账 500 块，跟李四说到账了，这时李四进行 `roll back`
- 不可重复读 
  - 一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这是事务 `update` 时引发的问题
  - 两次查询输出的结果不同，到底哪次是对的? 不知道以哪次为准。 有的时候这不是一个问题，当然是后面的为准。但是我们可以考虑这样一种情况，比如银行程序需要将查询结果分别输出到电脑屏幕和发短信给客 户，结果在一个事务中针对不同的输出目的地进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作 人员就不知道以哪个为准了。 
  - 脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据
- 幻读
  - 一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致的，这是 `insert` 或 `delete` 时引发的问题
  - 幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从 "1" 修改为 "2" 的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为 "1" 并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。
  - 幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体(比如数据的个数)。

MySQL数据库有四种隔离级别 

- `read uncommitted`
  - 上面三种问题都有可能发生
- `read committed`
  - 不可能发生脏读，因为只有读到已提交的数据
- `repeatable read`
  - 可能发生幻读
  - 这时 MySQL 的默认隔离级别
- `serializable`
  - 所有的问题都不会发生

上面的级别最低，下面的级别最高，隔离级别越高，性能越差，安全性越高。在 MySQL 数据库中设置事务的隔离级别

```sql
set [glogal | session] transaction isolation level 隔离级别名称;
set tx_isolation='隔离级别名称';
```